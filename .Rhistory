corr<-cor.test("sulfate", "nitrate", alternative = c(“two.sided”, “less”, “greater”), method = c("pearson", "kendall", "spearman"),conf.level = 0.95)
}
corr <- function(directory, threshold = 0) {
filenames=list.files(directory,full.names=TRUE)
corr<-cor.test("sulfate", "nitrate")
}
cr<-corr("specdata",400)
corr <- function(directory, threshold = 0) {
filenames=list.files(directory,full.names=TRUE)
cor<-c()
for(i in id){
r[i]=sum(complete.cases(read.csv(filenames[i])))
}
corr<-cor.test("sulfate", "nitrate",r[i]>threshold)
cor<-corr
}
cr<-corr("specdata",400)
corr <- function(directory, threshold = 0) {
corrsNum <- numeric(0)
nobsDfr <- complete("specdata")
nobsDfr <- nobsDfr[nobsDfr$nobs > threshold, ]
for (cid in nobsDfr$id) {
monDfr <- getmonitor(cid, directory)
corrsNum <- c(corrsNum, cor(monDfr$sulfate, monDfr$nitrate, use = "pairwise.complete.obs"))
}
return(corrsNum)
}
complete=function(directory,id=1:332){
filenames=list.files(directory,full.names=TRUE)
nobs <- c()
for(i in id){
nobs[i]=sum(complete.cases(read.csv(filenames[i])))
}
nobs <- na.omit(nobs)
data_comp=data.frame(id,nobs)
data_comp
}
getmonitor <- function(id, directory, summarize = FALSE) {
# --- Assert 'id' is a vector of length 1 indicating the monitor ID
# number. The user can specify 'id' as either an integer, a character, or
# a numeric.  'directory' is a character vector of length 1 indicating the
# location of the CSV files 'summarize' is a logical indicating whether a
# summary of the data should be printed to the console; the default is
# FALSE
# --- Assert construct file name Directory is pre-appended to file name.
# Use sprintf() to add leading zeroes.  E.g. 'specdata/001.csv'
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
return(rawDfr)
}
cr<-corr("specdata",400)
head(cr)
summary(cr)
corr <- function(directory, threshold = 0) {
corrsNum <- numeric(0)
nobsDfr <- complete("specdata")
nobsDfr <- nobsDfr[nobsDfr$nobs > threshold, ]
for (cid in nobsDfr$id) {
monDfr <- getmonitor(cid, directory)
corrsNum <- c(corrsNum, cor(monDfr$sulfate, monDfr$nitrate, use = "pairwise.complete.obs"))
}
return(corrsNum)
}
complete=function(directory,id=1:332){
filenames=list.files(directory,full.names=TRUE)
nobs <- c()
for(i in id){
nobs[i]=sum(complete.cases(read.csv(filenames[i])))
}
nobs <- na.omit(nobs)
data_comp=data.frame(id,nobs)
data_comp
}
getmonitor <- function(id, directory, summarize = FALSE) {
# --- Assert 'id' is a vector of length 1 indicating the monitor ID
# number. The user can specify 'id' as either an integer, a character, or
# a numeric.  'directory' is a character vector of length 1 indicating the
# location of the CSV files 'summarize' is a logical indicating whether a
# summary of the data should be printed to the console; the default is
# FALSE
# --- Assert construct file name Directory is pre-appended to file name.
# Use sprintf() to add leading zeroes.  E.g. 'specdata/001.csv'
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
return(rawDfr)
round(rawDfr, 3)
}
cr<-corr("specdata")
head(cr)
cr<-corr("specdata",150)
head(cr)
corr <- function(directory, threshold = 0) {
corrsNum <- numeric(0)
nobsa <- complete("specdata")
nobsa <- nobsa[nobsa$nobs > threshold, ]
for (cid in nobsa$id) {
mona <- getmonitor(cid, directory)
corrsNum <- c(corrsNum, cor(mona$sulfate, mona$nitrate, use = "pairwise.complete.obs"))
}
return(corrsa)
}
complete=function(directory,id=1:332){
filenames=list.files(directory,full.names=TRUE)
nobs <- c()
for(i in id){
nobs[i]=sum(complete.cases(read.csv(filenames[i])))
}
nobs <- na.omit(nobs)
data_comp=data.frame(id,nobs)
data_comp
}
getmonitor <- function(id, directory, summarize = FALSE) {
# --- Assert 'id' is a vector of length 1 indicating the monitor ID
# number. The user can specify 'id' as either an integer, a character, or
# a numeric.  'directory' is a character vector of length 1 indicating the
# location of the CSV files 'summarize' is a logical indicating whether a
# summary of the data should be printed to the console; the default is
# FALSE
# --- Assert construct file name Directory is pre-appended to file name.
# Use sprintf() to add leading zeroes.  E.g. 'specdata/001.csv'
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
return(rawDfr)
round(rawDfr, 5)
}
cr<-corr("specdata",150)
> head(cr)
corr <- function(directory, threshold = 0) {
corrsNum <- numeric(0)
nobsDfr <- complete("specdata")
nobsDfr <- nobsDfr[nobsDfr$nobs > threshold, ]
for (cid in nobsDfr$id) {
monDfr <- getmonitor(cid, directory)
corrsNum <- c(corrsNum, cor(monDfr$sulfate, monDfr$nitrate, use = "pairwise.complete.obs"))
}
return(corrsNum)
}
complete <- function(directory, id = 1:332) {
# --- Assert 'directory' is a character vector of length 1 indicating the
# location of the CSV files.  'id' is an integer vector indicating the
# monitor ID numbers to be used Return a data frame of the form: id nobs 1
# 117 2 1041 ...  where 'id' is the monitor ID number and 'nobs' is the
# number of complete cases
# --- Assert create an empty vector
nobsNum <- numeric(0)
for (cid in id) {
# --- Assert get data frame as ID
cDfr <- getmonitor(cid, directory)
# --- Assert count the number of complete cases and append to numeric
# vector
nobsNum <- c(nobsNum, nrow(na.omit(cDfr)))
}
# --- Assert return value is a data frame with TWO (2) columns
data.frame(id = id, nobs = nobsNum)
}
getmonitor <- function(id, directory, summarize = FALSE) {
# --- Assert 'id' is a vector of length 1 indicating the monitor ID
# number. The user can specify 'id' as either an integer, a character, or
# a numeric.  'directory' is a character vector of length 1 indicating the
# location of the CSV files 'summarize' is a logical indicating whether a
# summary of the data should be printed to the console; the default is
# FALSE
# --- Assert construct file name Directory is pre-appended to file name.
# Use sprintf() to add leading zeroes.  E.g. 'specdata/001.csv'
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
round(rawDfr,5)
}
cr<-corr("specdata",150)
corr <- function(directory, threshold = 0) {
# --- Assert 'directory' is a character vector of length 1 indicating the
# location of the CSV files.  'threshold' is a numeric vector of length 1
# indicating the number of completely observed observations (on all
# variables) required to compute the correlation between nitrate and
# sulfate; the default is 0.  Return a numeric vector of correlations.
# --- Assert create an empty numeric vector
corrsNum <- numeric(0)
# --- Assert get a data frame as ID = 1:332
nobsDfr <- complete("specdata")
# --- Assert apply threshold
nobsDfr <- nobsDfr[nobsDfr$nobs > threshold, ]
for (cid in nobsDfr$id) {
# --- Assert get a data frame as ID in $id
monDfr <- getmonitor(cid, directory)
# --- Assert calculate correlation between $sulfate and $nitrate
corrsNum <- c(corrsNum, cor(monDfr$sulfate, monDfr$nitrate, use = "pairwise.complete.obs"))
}
# --- Assert return value is a numeric vector of correlations
return(corrsNum)
}
complete <- function(directory, id = 1:332) {
# --- Assert 'directory' is a character vector of length 1 indicating the
# location of the CSV files.  'id' is an integer vector indicating the
# monitor ID numbers to be used Return a data frame of the form: id nobs 1
# 117 2 1041 ...  where 'id' is the monitor ID number and 'nobs' is the
# number of complete cases
# --- Assert create an empty vector
nobsNum <- numeric(0)
for (cid in id) {
# --- Assert get data frame as ID
cDfr <- getmonitor(cid, directory)
# --- Assert count the number of complete cases and append to numeric
# vector
nobsNum <- c(nobsNum, nrow(na.omit(cDfr)))
}
# --- Assert return value is a data frame with TWO (2) columns
data.frame(id = id, nobs = nobsNum)
}
getmonitor <- function(id, directory, summarize = FALSE) {
# --- Assert 'id' is a vector of length 1 indicating the monitor ID
# number. The user can specify 'id' as either an integer, a character, or
# a numeric.  'directory' is a character vector of length 1 indicating the
# location of the CSV files 'summarize' is a logical indicating whether a
# summary of the data should be printed to the console; the default is
# FALSE
# --- Assert construct file name Directory is pre-appended to file name.
# Use sprintf() to add leading zeroes.  E.g. 'specdata/001.csv'
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
return(rawDfr)
}
cr<-corr("specdata",150)
head(cr)
corr <- function(directory, threshold = 0) {
corrsNum <- numeric(0)
nobsDfr <- complete("specdata")
nobsDfr <- nobsDfr[nobsDfr$nobs > threshold, ]
for (cid in nobsDfr$id) {
monDfr <- getmonitor(cid, directory)
corrsNum <- c(corrsNum, cor(monDfr$sulfate, monDfr$nitrate, use = "pairwise.complete.obs"))
}
return(corrsNum)
}
complete <- function(directory, id = 1:332) {
nobsNum <- numeric(0)
for (cid in id) {
cDfr <- getmonitor(cid, directory)
nobsNum <- c(nobsNum, nrow(na.omit(cDfr)))
}
# --- Assert return value is a data frame with TWO (2) columns
data.frame(id = id, nobs = nobsNum)
}
getmonitor <- function(id, directory, summarize = FALSE) {
fileStr <- paste(directory, "/", sprintf("%03d", as.numeric(id)), ".csv",
sep = "")
# --- Assert read csv
rawDfr <- read.csv(fileStr)
# --- Assert summary if true
if (summarize) {
print(summary(rawDfr))
}
# --- Return value is a data frame
return(rawDfr)
}
submit()
source("submitscript1.R")
submit()
9
submit()
submit()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
alist<-makeVector(c(1,3,5,7,11))
cachemean(alist)
alist$getmean()
makeVector<-function(x=numeric()){
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function(){
x
}
setmean<-function(mean){
m<<-mean
}
getmean<-function(){
m
}
list(set=set,get=get,setmean=setmean,getmean=getmean)
}
makeVector(1)
ls(makeVector)
environment(makeVector)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
## Return a matrix that is the inverse of 'x'
}
x<-matrix(1:9,3,3)
cacheSolve(x)
x<-matrixx(1:9,3,3)
x<-matrix(1:9,3,3)
CacheSolve=makeCacheMatrix(x)
cachex=makeCacheMatrix
CacheSolve(cachex)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
## Return a matrix that is the inverse of 'x'
}
x<-matrix(1:9,3,3)
cachex=makeCacheMatrix
CacheSolve(cachex)
cacheSolve(cachex)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
## Return a matrix that is the inverse of 'x'
}
x<-matrix(1:9,3,3)
cachex=makeCacheMatrix(x)
cacheSolve(cachex)
x<-matrix(c(1,0,0,0,1,0,0,0,1),3,3)
cachex=makeCacheMatrix(x)
cacheSolve(cachex)
cacheSolve(cachex)
## This function creates a special "matrix" object that can cache its inverse.
## We use it just because we need to get the inverse of 'x' from the environment of definition.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed),
## then cacheSolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
x<-matrix(c(1,0,0,0,1,0,0,0,1),3,3)
cachex=makeCacheMatrix(x)
cacheSolve(cachex)
## This function creates a special "matrix" object that can cache its inverse.
## We use it just because we need to get the inverse of 'x' from the environment of definition.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
matrix(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed),
## then cacheSolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
x<-matrix(c(1,0,0,0,1,0,0,0,1),3,3)
cachex=makeCacheMatrix(x)
cacheSolve(cachex)
setwd("C:/Users/Administrator/ProgrammingAssignment2")
